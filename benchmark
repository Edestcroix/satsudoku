#! /usr/bin/env python3
import argparse
import os
import re
import shutil
import subprocess

import src.convertCNF as Cnf
import src.convertSUD as Sud
from src.tableMD import create as create_table
from src.convertCNF import Encoding

CACHE_DIR = ".working/"
PUZZLE_DIR = "data/puzzles/"
RESULTS_DIR = "benchmarks/"

ROUND_AVG = 2


def main():

    if not os.path.isdir(CACHE_DIR):
        os.mkdir(CACHE_DIR)

    if not os.path.isdir(RESULTS_DIR):
        os.mkdir(RESULTS_DIR)

    # set up argument parser
    # with argument flag -c
    # which shows the CPU time for each puzzle
    parser = argparse.ArgumentParser(
        description="Run tests on the sudoku solver")
    parser.add_argument("-s", "--silent", action="store_true",)
    # add argument flag -t to specify which test to run
    # default is to run all tests
    parser.add_argument("-t", "--test", type=str, default="",
                        help="test to run (standard, hard)")
    parser.add_argument("-e", "--enc", type=str, default="",
                        help="encoding to use (min, eff, ext)")

    parser.add_argument("-a", "--all", action="store_true",
                        help="run all tests")
    parser.add_argument("-k", "--keep", action="store_true",
                        help="keep converted CNF files and solver output")
    parser.add_argument("-S", "--summarize", action="store_true",
                        help="summarize results from -a")
    parser.add_argument("-d", "--decode", action="store_true",
                        help="decode solved puzzles")
    parser.add_argument("-C", "--complete", action="store_true",
                        help="run all tests and summarize results")
    parser.add_argument("-c", "--clean", action="store_true",
                        help="clean benchmark directory")
    args = parser.parse_args()
    if args.clean:
        shutil.rmtree(RESULTS_DIR)
        exit(0)

    all_tests = args.all or args.complete
    summary = args.summarize or args.complete
    keep = args.keep or args.complete
    decode = args.decode or args.complete

    if summary and not all_tests:
        print("Error: -S must be used with -a")
        return

    if all_tests:
        # fail if -t or -e specified with -a
        if args.test != "" or args.enc != "":
            print("Error: -a/-C cannot be used with flags other -s")
            return
        run_all_tests(args.silent, summary)
    else:
        match args.enc:
            case "eff": enc = Encoding.EFFICIENT
            case "efficient": enc = Encoding.EFFICIENT
            case "ext": enc = Encoding.EXTENDED
            case "extended": enc = Encoding.EXTENDED
            case "min": enc = Encoding.MINIMAL
            case "minimal": enc = Encoding.MINIMAL
            case "": enc = Encoding.MINIMAL
            case _:
                print("Error: invalid encoding")
                exit(1)

        out = f"{RESULTS_DIR}test_results.md"
        match args.test:
            case "hard": test_hard(args.silent, enc, out)
            case "standard": test_standard(args.silent, enc, out)
            case "": test_standard(args.silent, enc, out)
            case _:
                print("Error: invalid test")
                exit(1)

    if decode:
        copy_solution_dir(args)
    if keep:
        copy_working_dir(args)
    else:
        shutil.rmtree(CACHE_DIR)

    exit(0)


def copy_solution_dir(args):
    out_dir = RESULTS_DIR
    # add trailing slash if not present
    if out_dir[-1] != "/":
        out_dir += "/"
    decode_solutions()
    if os.path.isdir(f"{out_dir}solutions"):
        shutil.rmtree(f"{out_dir}solutions")
    shutil.move(f"{CACHE_DIR}solutions", out_dir)
    if not args.silent:
        print(f"Decoded solutions written to {out_dir}solutions")


def copy_working_dir(args):
    # move contents cache dir to results dir
    out_dir = RESULTS_DIR
    # add trailing slash if not present
    if out_dir[-1] != "/":
        out_dir += "/"

    if not os.path.isdir(out_dir):
        os.mkdir(out_dir)
    if os.path.isdir(f"{out_dir}.working"):
        shutil.rmtree(f"{out_dir}.working")
    shutil.move(CACHE_DIR, out_dir)
    if os.path.isdir(f"{out_dir}encodings"):
        shutil.rmtree(f"{out_dir}encodings")
    os.rename(f"{out_dir}.working", f"{out_dir}encodings")

    if not args.silent:
        print("Converted CNF files and solver output saved to " +
              out_dir+"encodings")


def run_all_tests(silent, summarize):
    # fail if any flags other than -o and -s are specified

    out = RESULTS_DIR

    # add / if not present
    if out != "" and out[-1] != "/":
        out += "/"

    if not silent:
        test_all(summarize)
    else:
        test_all_silent(summarize)


def summarize(results):

    sum_file = f"{RESULTS_DIR}summary.md"
    def header_func(x): return "Averages ― Standard Puzzles" if\
        x == 1 else "Averages ― Hard Puzzles"
    cols = ["Encoding", "Decisions", "Decision Rate (dcsns/sec)",
            "Propositions", "Proposition Rate (props/sec)", "CPU Time (seconds)"]
    with open(sum_file, "w") as f:
        f.write(create_table("Results Summary", results,
                cols, sep_func=header_func, new_line=False))


# TODO Rename this here and in `run_all_tests`
def test_all_silent(summary=False):
    out = RESULTS_DIR
    results = [test_standard(True, Encoding.MINIMAL,
                             f"{out}01-standard-min.md")]
    results.append(test_standard(
        True, Encoding.EFFICIENT, f"{out}02-standard-eff.md"))
    results.append(test_standard(
        True, Encoding.EXTENDED, f"{out}03-standard-ext.md"))
    results.append(test_hard(True, Encoding.MINIMAL, f"{out}04-hard-min.md"))
    results.append(test_hard(True, Encoding.EFFICIENT, f"{out}05-hard-eff.md"))
    results.append(test_hard(True, Encoding.EXTENDED, f"{out}06-hard-ext.md"))

    if summary:
        summarize(results)
    return results


# TODO Rename this here and in `run_all_tests`
def test_all(summary=False):
    out = RESULTS_DIR
    msg = "Testing {0} puzzles with {1} encoding..."
    print(f"Running all tests, outputting to {out}")
    print("This may take a while...")

    print(format(msg.format("standard", "minimal")))
    results = [test_standard(True, Encoding.MINIMAL,
                             f"{out}01-standard-min.md")]

    print(format(msg.format("standard", "efficient")))
    results.append(test_standard(
        True, Encoding.EFFICIENT, f"{out}02-standard-eff.md"))

    print(format(msg.format("standard", "extended")))
    results.append(test_standard(
        True, Encoding.EXTENDED, f"{out}03-standard-ext.md"))

    print(format(msg.format("hard", "minimal")))
    results.append(test_hard(True, Encoding.MINIMAL, f"{out}04-hard-min.md"))

    print(format(msg.format("hard", "efficient")))
    results.append(test_hard(True, Encoding.EFFICIENT, f"{out}05-hard-eff.md"))

    print(format(msg.format("hard", "extended")))
    results.append(test_hard(True, Encoding.EXTENDED, f"{out}06-hard-ext.md"))

    print("Done!")
    if summary:
        summarize(results)
        print(f"Summary saved to {out}summary.md")


def header(test="Standard", enc=Encoding.MINIMAL):
    match enc:
        case Encoding.EFFICIENT: enc = "Efficient"
        case Encoding.EXTENDED: enc = "Extended"
        case _: enc = "Minimal"
    return f"{test} Test ({enc} Encoding)"


def test_standard(silent=False, enc=Encoding.MINIMAL, out_dir=""):
    # read /puzzles/p096_sudoku.txt
    filename = f"{PUZZLE_DIR}p096_sudoku.txt"
    file = open(filename, "r")
    # each puzzle is 9 lines long
    # headed by "Grid xx"
    # where xx is the puzzle number
    # the first puzzle is 1
    # the last puzzle is 50

    working_dir = f"{CACHE_DIR}{enc.name.lower()}/standard/"
    mkdir = f"mkdir -p {working_dir}"
    os.system(mkdir)
    for i in range(50):
        # read the header
        file.readline()
        puzzle = "".join(file.readline() for _ in range(9))
        # convert to CNF
        cnf = Cnf.convert(puzzle, enc)
        # write to file

        # pad number in filename with zero for single digits
        filename = f"{working_dir}/sudoku_{str(i+1).zfill(2)}.cnf"

        with open(filename, "w") as f:
            f.write(cnf)

    # call sat_solve
    head = header("Standard", enc)
    name = enc.name.lower().capitalize()
    return [name] + sat_solve(silent, working_dir, 50, out_dir, head)


def test_hard(silent=False, enc=Encoding.MINIMAL, out_dir=""):
    # read /puzzles/p096_sudoku.txt
    filename = f"{PUZZLE_DIR}top95"

    working_dir = f"{CACHE_DIR}{enc.name.lower()}/hard/"
    mkdir = f"mkdir -p {working_dir}"
    os.system(mkdir)
    with open(filename, "r") as in_file:
        # each puzzle is one line, there are 95 puzzles
        for i in range(95):
            # read the puzzle
            puzzle = in_file.readline()
            # convert to CNF
            cnf = Cnf.convert(puzzle, enc)
            # write to file

            # pad number in filename with zero for single digits
            filename = f"{working_dir}/sudoku_{str(i + 1).zfill(2)}.cnf"

            with open(filename, "w") as outfile:
                outfile.write(cnf)

    name = enc.name.lower().capitalize()
    head = header("Hard", enc)
    return [name] + sat_solve(silent, working_dir, 95, out_dir, head)


def sat_solve(silent, in_dir="", c=50, out_dir="", header=""):
    # iterate through CNF output and call minisat on each
    work_dir = f"{CACHE_DIR}/sat/standard/" if "standard" in in_dir else f"{CACHE_DIR}/sat/hard/"
    os.system(f"mkdir -p {work_dir}")
    times, props, rates, decisions, d_rates = [], [], [], [], []
    table_rows = []
    for i in range(c):
        filename = f"{in_dir}/sudoku_{str(i + 1).zfill(2)}.cnf"
        outfile = f"{work_dir}/sudoku_{str(i + 1).zfill(2)}.out"
        minisat = f"minisat {filename} {outfile}"

        # intercept stdout, don't let it print to terminal
        output = subprocess.Popen(
            minisat, shell=True, stdout=subprocess.PIPE).communicate()[0]
        output = output.decode("utf-8").split("\n")

        def want_line(
            l): return "CPU time" in l or "propagations" in l or "decisions" in l

        data = [line for line in output if want_line(line)]

        decision = data[0]
        vals = re.findall(r"[-+]?\d*\.\d+|\d+", decision)
        decision = vals[0]
        decision_rate = f"{vals[2]} decisions/sec"
        decisions.append(decision)
        d_rates.append(vals[2])

        prop = data[1]
        vals = re.findall(r"[-+]?\d*\.\d+|\d+", prop)
        prop = vals[0]
        rates.append(vals[1])
        rate = f"{vals[1]} props/sec"

        cpu = data[2].split(":")

        # append a result row to the table
        table_rows.append([decision.strip(), decision_rate.strip(),
                           prop.strip(), rate.strip(), cpu[1].strip()])

        times.append(cpu[1].strip().replace(" s", ""))
        props.append(prop)

    # add result table for averages of the results
    averages = []
    for avg in [props, rates, decisions, d_rates]:
        avg = [float(x) for x in avg]
        averages.append(round(sum(avg) / len(avg), ROUND_AVG))

    av_prop, av_rate, av_dec, av_d_rate = averages
    av_time = round(sum(float(x) for x in times) / len(times), ROUND_AVG+2)
    table_rows.append([av_dec, f"{av_d_rate} decisions/sec", av_prop,
                       f"{av_rate} props/sec", f"{av_time} s"])

    # add a header to the table, the number of puzzles
    # is specified by c, which will be the number of result tables.
    # after this, one more table will be added for the averages,
    # so once i passes c, the header will be changed to "Averages".
    def header_func(i):
        return f"Test {str(i).zfill(2)}" if i <= c else "Averages"

    if table_rows != []:
        cols = ["Decisions", "Decision Rate", "Propagations",
                "Propagation Rate", "CPU Time"]
        table = create_table(header, table_rows, cols,
                             sep_every=1, new_line=False, sep_func=header_func)

        if not silent:
            print(table)
        if out_dir != "":
            out_dir = out_dir \
                if out_dir[-4:] == ".txt" or out_dir[-3:] == ".md"\
                else f"{out_dir}test_results.md"

            with open(out_dir, "a") as outfile:
                outfile.write(table)
        averages.append(av_time)

    return (averages)


def decode_solutions():
    # decode solutions from minisat output
    standard_dir = f"{CACHE_DIR}sat/standard/"
    hard_dir = f"{CACHE_DIR}sat/hard/"
    if os.path.exists(standard_dir):
        decode_dir('solutions/standard/', standard_dir,
                   'solutions/standard/sudoku_')
    if os.path.exists(f"{CACHE_DIR}sat/hard"):
        decode_dir('/solutions/hard/', hard_dir, 'solutions/hard/sudoku_')


def decode_dir(out_dir, in_dir, out_name_head):
    os.system(f"mkdir -p {CACHE_DIR}{out_dir}")
    # count how many files are in standard_dir
    count = len(list(os.listdir(in_dir)))
    for i in range(count):
        filename = f"{in_dir}sudoku_{str(i + 1).zfill(2)}.out"
        # read file and pass to Sud.convert
        with open(filename, "r") as in_file:
            lines = in_file.readlines()

            table = sudoku_to_table(Sud.convert(lines[1]), i)
            outfile = f"{CACHE_DIR}{out_name_head}{str(i + 1).zfill(2)}.md"

            with open(outfile, "w") as out:
                out.write(table)


def sudoku_to_table(sudoku, i):
    # convert a sudoku puzzle to a table
    sudoku = sudoku.replace(" ", "").split("\n")
    sudoku = [line for line in sudoku if line != ""]
    sudoku = [list(line) for line in sudoku]
    dummy = [""] * 9
    sudoku = [dummy] + sudoku

    return create_table(f"Solution {str(i+1).zfill(2)}", sudoku, new_line=False, sep=False)


if __name__ == "__main__":
    main()

#! /usr/bin/env python3
import os
import shutil
import subprocess
import argparse
import re
from timeit import Timer
from src.convertCNF import SudokuToCNF, Encoding


TEST_DIR = "benchmarks/"
CACHE_DIR = ".working/"
PUZZLE_DIR = "data/puzzles/"
RESULTS_DIR = TEST_DIR


ROUND_AVG = 2


TIME = -5
DECISIONS = -4
DECISION_RATE = -3
PROPOSITIONS = -2
PROPOSITION_RATE = -1


def main():

    if not os.path.isdir(CACHE_DIR):
        os.mkdir(CACHE_DIR)
    if not os.path.isdir(RESULTS_DIR):
        os.mkdir(RESULTS_DIR)

    # set up argument parser
    # with argument flag -c
    # which shows the CPU time for each puzzle
    parser = argparse.ArgumentParser(
        description="Run tests on the sudoku solver")
    parser.add_argument("-s", "--silent", action="store_true",)
    # add argument flag -t to specify which test to run
    # default is to run all tests
    parser.add_argument("-t", "--test", type=str, default="",
                        help="test to run (easy, hard)")
    parser.add_argument("-e", "--enc", type=str, default="",
                        help="encoding to use (min, eff, ext)")
    parser.add_argument("-o", "--out", type=str,
                        default="", help="output directory")
    parser.add_argument("-a", "--all", action="store_true",
                        help="run all tests")
    parser.add_argument("-k", "--keep", action="store_true",
                        help="keep converted CNF files and solver output")
    parser.add_argument("-S", "--summarize", action="store_true",
                        help="summarize results from -a")
    args = parser.parse_args()

    # fail -s specified without -o
    if args.silent and not (args.out != "" or args.all):
        print("Error: -s must be used with -o or -a")
        return

    if args.summarize and not args.all:
        print("Error: -S must be used with -a")
        return

    if args.all:
        run_all_tests(args)
    else:
        match args.enc:
            case "eff": enc = Encoding.EFFICIENT
            case "efficient": enc = Encoding.EFFICIENT
            case "ext": enc = Encoding.EXTENDED
            case "extended": enc = Encoding.EXTENDED
            case "min": enc = Encoding.MINIMAL
            case "minimal": enc = Encoding.MINIMAL
            case "": enc = Encoding.MINIMAL
            case _:
                print("Error: invalid encoding")
                exit(1)

        match args.test:
            case "hard": test_hard(args.silent, enc, args.out)
            case _: test_easy(args.silent, enc, args.out)

    if args.keep:
        # move contents cache dir to results dir
        out_dir = RESULTS_DIR if args.out == "" else args.out
        if not os.path.isdir(out_dir):
            os.mkdir(out_dir)
        if os.path.isdir(out_dir + ".working"):
            shutil.rmtree(out_dir + ".working")
        shutil.move(CACHE_DIR, out_dir)
        if os.path.isdir(out_dir + "encodings"):
            shutil.rmtree(out_dir + "encodings")
        os.rename(out_dir + ".working", out_dir + "encodings")

        if not args.silent:
            print("Converted CNF files and solver output saved to " +
                  out_dir+"encodings")

    else:
        shutil.rmtree(CACHE_DIR)

    if args.summarize:
        summarize_results(args.out)


def summarize_results(out_dir=""):
    # for every file in results dir
    # get the last line
    sum_file = RESULTS_DIR + "summary.md" if out_dir == "" else out_dir + "/summary.md"
    table_rows = []
    for file in os.listdir(RESULTS_DIR):
        if file.endswith(".md") and file != "summary.md":
            with open(RESULTS_DIR + file, "r") as f:
                lines = f.readlines()
                # format first line to remove first 10 chars and last char
                # and add spaces to the end to make it 40 chars long
                first_line = lines[0][10:-1]
                first_line += " "*(20-len(first_line))
                # remove (, and ) from first line
                first_line = first_line.replace("(", "").replace(")", "")
                first_line = first_line.replace(" Encoding", "")

                # get the float or int for time, prop, and rate
                dcsn = re.findall(r"(\d+(?:\.\d+)?)", lines[DECISIONS])[0]
                dcsn_rate = re.findall(
                    r"(\d+(?:\.\d+)?) decisions/sec", lines[DECISION_RATE])[0]
                prop = re.findall(r"(\d+(?:\.\d+)?)", lines[PROPOSITIONS])[0]
                rate = re.findall(r"(\d+(?:\.\d+)?) props/sec",
                                  lines[PROPOSITION_RATE])[0]
                time = re.findall(r"(\d+(?:\.\d+)?) seconds", lines[TIME])[0]
                table_rows.append(
                    (first_line, dcsn, dcsn_rate, prop, rate, time))

    with open(sum_file, "w") as s:
        def header_func(
            x): return "Averages ― Easy Puzzles" if x == 1 else "Averages ― Hard Puzzles"
        cols = ["Encoding", "Decisions", "Decision Rate (dcsns/sec)",
                "Propositions", "Proposition Rate (props/sec)", "Time (seconds)"]
        s.write(Table().create(table_rows, cols, sep_func=header_func,
                new_line=False))
    print("Results summarized to " + sum_file)


def run_all_tests(args):
    # fail if any flags other than -o and -s are specified
    if args.test != "" or args.enc != "":
        print("Error: -a cannot be used with flags other than -o and -s")
        return

    if not os.path.isdir(RESULTS_DIR):
        os.mkdir(RESULTS_DIR)

    if args.out == "":
        out = RESULTS_DIR
    else:
        out = args.out
        # fail if out is specified but not a directory
        if os.path.exists(out) and not os.path.isdir(out):
            print("Error: -o must be a directory when using -a")
            return
        elif not os.path.exists(out):
            os.mkdir(out)

    # add / if not present
    if out != "" and out[-1] != "/":
        out += "/"

    def time(f): return "Time taken: " + \
        str(round(Timer(f).timeit(number=1), 4)) + "s"

    if not args.silent:
        msg = "Testing {0} puzzles with {1} encoding..."
        print("Running all tests, outputting to " + out)
        print("This may take a while...")
        print(format(msg.format("easy", "minimal")))
        print(time(lambda: test_easy(
            True, Encoding.MINIMAL, out+"01-easy-min.md")))

        print(format(msg.format("easy", "efficient")))
        print(time(lambda: test_easy(
            True, Encoding.EFFICIENT, out+"02-easy-eff.md")))

        print(format(msg.format("easy", "extended")))
        print(time(lambda: test_easy(
            True, Encoding.EXTENDED, out+"03-easy-ext.md")))

        print(format(msg.format("hard", "minimal")))
        print(time(lambda: test_hard(
            True, Encoding.MINIMAL, out+"04-hard-min.md")))

        print(format(msg.format("hard", "efficient")))
        print(time(lambda: test_hard(
            True, Encoding.EFFICIENT, out+"05-hard-eff.md")))

        print(format(msg.format("hard", "extended")))
        print(time(lambda: test_hard(
            True, Encoding.EXTENDED, out+"06-hard-ext.md")))

        print("Done!")
    else:
        test_easy(True, Encoding.MINIMAL, out+"01-easy-min.md")
        test_easy(True, Encoding.EFFICIENT, out+"02-easy-eff.md")
        test_easy(True, Encoding.EXTENDED, out+"03-easy-ext.md")
        test_hard(True, Encoding.MINIMAL, out+"04-hard-min.md")
        test_hard(True, Encoding.EFFICIENT, out+"05-hard-eff.md")
        test_hard(True, Encoding.EXTENDED, out+"06-hard-ext.md")


def header(test="Easy", enc=Encoding.MINIMAL):
    match enc:
        case Encoding.EFFICIENT: enc = "Efficient"
        case Encoding.EXTENDED: enc = "Extended"
        case _: enc = "Minimal"
    return test + " Test (" + enc + " Encoding)"


def test_easy(silent=False, enc=Encoding.MINIMAL, out_dir=""):
    # read /puzzles/p096_sudoku.txt
    filename = PUZZLE_DIR+"p096_sudoku.txt"
    file = open(filename, "r")
    # each puzzle is 9 lines long
    # headed by "Grid xx"
    # where xx is the puzzle number
    # the first puzzle is 1
    # the last puzzle is 50

    for i in range(50):
        # read the header
        file.readline()
        # read the puzzle
        puzzle = ""
        for _ in range(9):
            puzzle += file.readline()
        # convert to CNF
        cnf = SudokuToCNF().convert(puzzle, enc)
        # write to file
        mkdir = "mkdir -p " + CACHE_DIR+"easy/cnf"
        os.system(mkdir)

        # pad number in filename with zero for single digits
        filename = CACHE_DIR+"easy/cnf/sudoku_" + \
            str(i+1).zfill(2) + ".cnf"

        outfile = open(filename, "w")
        outfile.write(cnf)
        outfile.close()

    # call sat_solve
    sat_solve(silent, CACHE_DIR+"easy/", 50, out_dir, header("Easy", enc))


def test_hard(silent=False, enc=Encoding.MINIMAL, out_dir=""):
    # read /puzzles/p096_sudoku.txt
    filename = PUZZLE_DIR+"top95"
    file = open(filename, "r")
    # each puzzle is one line, there are 95 puzzles

    for i in range(95):
        # read the puzzle
        puzzle = file.readline()
        # convert to CNF
        cnf = SudokuToCNF().convert(puzzle, enc)
        # write to file
        mkdir = "mkdir -p " + CACHE_DIR+"hard/cnf"
        os.system(mkdir)

        # pad number in filename with zero for single digits
        filename = CACHE_DIR+"hard/cnf/sudoku_" + \
            str(i+1).zfill(2) + ".cnf"

        outfile = open(filename, "w")
        outfile.write(cnf)
        outfile.close()

    sat_solve(silent, CACHE_DIR+"hard/", 95, out_dir, header("Hard", enc))


def sat_solve(silent, dir="", c=50, out_dir="", header=""):
    # iterate through CNF output and call minisat on each
    if not silent:
        print(header)
    os.system("mkdir -p " + dir+"sol")
    times, props, rates, decisions, d_rates = [], [], [], [], []
    table_rows = []
    for i in range(c):
        filename = dir+"cnf/sudoku_" + str(i+1).zfill(2) + ".cnf"
        outfile = dir + "sol/sudoku_" + str(i+1).zfill(2) + ".out"
        minisat = "minisat " + filename + " " + outfile

        # intercept stdout, don't let it print to terminal
        output = subprocess.Popen(
            minisat, shell=True, stdout=subprocess.PIPE).communicate()[0]
        output = output.decode("utf-8").split("\n")

        def want_line(
            l): return "CPU time" in l or "propagations" in l or "decisions" in l
        data = [line for line in output if want_line(line)]

        decision = data[0]
        vals = re.findall(r"[-+]?\d*\.\d+|\d+", decision)
        decision = vals[0]
        decision_rate = vals[2] + " decisions/sec"
        decisions.append(decision)
        d_rates.append(vals[2])

        prop = data[1]
        vals = re.findall(r"[-+]?\d*\.\d+|\d+", prop)
        prop = vals[0]
        rates.append(vals[1])
        rate = vals[1] + " props/sec"

        cpu = data[2].split(":")

        table_rows.append(("Decisions", decision.strip()))
        table_rows.append(("Decision Rate", decision_rate.strip()))
        table_rows.append(("Propagations", prop.strip()))
        table_rows.append(("Propagation Rate", rate.strip()))
        table_rows.append((cpu[0].strip(), cpu[1].strip()))

        times.append(cpu[1].strip().replace(" s", ""))
        props.append(prop)

    averages = []
    for avg in [props, rates, decisions, d_rates]:
        avg = [float(x) for x in avg]
        averages. append(round(sum(avg) / len(avg), ROUND_AVG))

    av_prop, av_rate, av_dec, av_d_rate = averages
    av_time = round(sum([float(x) for x in times]) / len(times), ROUND_AVG+2)

    if table_rows != [] and not silent:
        print(header+"\n"+"-"*len(header))
        def header_func(i): return "Test " + str(i).zfill(2)
        print(Table().create(table_rows, col_titles=[
              "Metric", "Value"], sep_every=5, new_line=False, sep_func=header_func))
        print("Average CPU Time: " + str(av_time) + " seconds")
        print("Average Decisions: " + str(av_dec))
        print("Average Decision Rate: " + str(av_d_rate) + " decisions/sec")
        print("Average Propagations: " + str(av_prop))
        print("Average Propagation Rate: " + str(av_rate) + " props/sec")
    elif table_rows != []:
        # check if a file was specified
        if out_dir[-4:] == ".txt" or out_dir[-3:] == ".md":
            # if there is a file specified, write to that file
            outfile = open(out_dir, "w")
        else:
            # otherwise make a file in the specified directory
            outfile = open(out_dir + "test_results.md", "w")

        if header != "":
            outfile.write(header + "\n")
        outfile.write(Table().create(
            table_rows, ["Metric", "Value"], 5, lambda s: "Test "+str(s).zfill(2)))
        if av_time != 0:
            outfile.write("# Averages\n")
            outfile.write("Average CPU Time: " +
                          str(av_time) + " seconds  \n")
            outfile.write("Average Decisions: " + str(av_dec) + "  \n")
            outfile.write("Average Decision Rate: " +
                          str(av_d_rate) + " decisions/sec  \n")
            outfile.write("Average Propagations: " +
                          str(av_prop) + "  \n")
            outfile.write("Average Propagation Rate: " +
                          str(av_rate) + " props/sec  ")
        outfile.close()


class Table:
    def __table_sep(self, sep_count, sep_func, sep_line, col_widths, col_titles):

        out = ""
        # when a separator of some kind is defined
        # (either a header or a function)
        # print the separator at the interval specified by sep_every
        if sep_func != None:
            # the header is generated by the function
            # passed as an argument to sep_func
            # (this is so that the header can be dynamic)
            head = sep_func(sep_count)

            sep_header = "# " + head.ljust(sum(col_widths) + 3 *
                                           (len(col_widths)-1)) + "\n\n"
            if sep_count > 1:
                out += "\n"+sep_header
            else:
                out += sep_header

        # if there are no column titles, and no separator function
        # a separator line needs to be printed
        if sep_func == None:
            out += sep_line

        out += "| " + " | ".join((str(x).ljust(col_widths[j])
                                  for j, x in enumerate(col_titles))) + " |\n"
        out += sep_line
        return out

    # yes, this function is an almost unreadable mess. Will I fix it? Probably not.
    # It works, and no one else will ever have to read it, so I don't care.
    def create(self, rows, col_titles, sep_every=3, sep_func=None, new_line=True):
        # find the longest string in each column
        col_widths = [max(len(str(x)) for x in col)
                      for col in zip(*rows + [col_titles])]
        out = ""
        sep_count = 0
        sep_line = "|-" + "-|-".join("-" * n for n in col_widths) + "-|" + "\n"

        for i, row in enumerate(rows):
            if i % sep_every == 0:
                sep_count += 1
                out += self.__table_sep(sep_count, sep_func,
                                        sep_line, col_widths, col_titles)

            out += "| " + " | ".join((str(x).ljust(col_widths[j])
                                      for j, x in enumerate(row))) + " |\n"

        if new_line:
            out += "\n"
        return out


if __name__ == "__main__":
    main()

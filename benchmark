#! /usr/bin/env python3
import os
import shutil
import subprocess
import argparse
import re
from timeit import Timer
from src.convertCNF import SudokuToCNF, Encoding


TEST_DIR = "benchmarks/"
WORKING_DIR = TEST_DIR + "working/"
PUZZLE_DIR = "data/puzzles/"


def main():

    if not os.path.isdir(WORKING_DIR):
        os.mkdir(WORKING_DIR)

    # set up argument parser
    # with argument flag -c
    # which shows the CPU time for each puzzle
    parser = argparse.ArgumentParser()
    parser.add_argument("-s", "--silent", action="store_true",)
    # add argument flag -t to specify which test to run
    # default is to run all tests
    parser.add_argument("-t", "--test", type=str, default="",
                        help="test to run (easy, hard)")
    parser.add_argument("-e", "--enc", type=str, default="",
                        help="encoding to use (min, eff, ext)")
    parser.add_argument("-o", "--out", type=str,
                        default="", help="output directory")
    parser.add_argument("-a", "--all", action="store_true",
                        help="run all tests")
    parser.add_argument("-k", "--keep", action="store_true",
                        help="keep working directory")
    args = parser.parse_args()

    # fail -s specified without -o
    if args.silent and not (args.out != "" or args.all):
        print("Error: -s must be used with -o or -a")
        return

    if args.all:

        # fail if any flags other than -o and -s are specified
        if args.test != "" or args.enc != "":
            print("Error: -a cannot be used with flags other than -o and -s")
            return

        if not os.path.isdir(TEST_DIR + "summary/"):
            os.mkdir(TEST_DIR + "summary/")

        if args.out == "":
            out = TEST_DIR + "summary/"
        else:
            out = args.out
            # fail if out is specified but not a directory
            if os.path.exists(out) and not os.path.isdir(out):
                print("Error: -o must be a directory when using -a")
                return
            elif not os.path.exists(out):
                os.mkdir(out)

        # add / if not present
        if out != "" and out[-1] != "/":
            out += "/"

        msg = "Testing {0} puzzles with {1} encoding"

        def time(f): return "Time taken: " + \
            str(round(Timer(f).timeit(number=1), 4)) + "s"

        if not args.silent:
            print("Running all tests, outputting to " + out)
            print("This may take a while...")
            print(format(msg.format("easy", "minimal")))
            print(time(lambda: test_easy(
                True, Encoding.MINIMAL, out+"01-easy-min.txt")))

            print(format(msg.format("easy", "efficient")))
            print(time(lambda: test_easy(
                True, Encoding.EFFICIENT, out+"02-easy-eff.txt")))

            print(format(msg.format("easy", "extended")))
            print(time(lambda: test_easy(
                True, Encoding.EXTENDED, out+"03-easy-ext.txt")))

            print(format(msg.format("hard", "minimal")))
            print(time(lambda: test_hard(
                True, Encoding.MINIMAL, out+"04-hard-min.txt")))

            print(format(msg.format("hard", "efficient")))
            print(time(lambda: test_hard(
                True, Encoding.EFFICIENT, out+"05-hard-eff.txt")))

            print(format(msg.format("hard", "extended")))
            print(time(lambda: test_hard(
                True, Encoding.EXTENDED, out+"06-hard-ext.txt")))

            print("Done!")
        else:
            test_easy(True, Encoding.MINIMAL, out+"01-easy-min.txt")
            test_easy(True, Encoding.EFFICIENT, out+"02-easy-eff.txt")
            test_easy(True, Encoding.EXTENDED, out+"03-easy-ext.txt")
            test_hard(True, Encoding.MINIMAL, out+"04-hard-min.txt")
            test_hard(True, Encoding.EFFICIENT, out+"05-hard-eff.txt")
            test_hard(True, Encoding.EXTENDED, out+"06-hard-ext.txt")

    else:
        match args.enc:
            case "eff": enc = Encoding.EFFICIENT
            case "efficient": enc = Encoding.EFFICIENT
            case "ext": enc = Encoding.EXTENDED
            case "extended": enc = Encoding.EXTENDED
            case "min": enc = Encoding.MINIMAL
            case "minimal": enc = Encoding.MINIMAL
            case _:
                print("Error: invalid encoding")
                exit(1)

        match args.test:
            case "hard": test_hard(args.silent, enc, args.out)
            case _: test_easy(args.silent, enc, args.out)

    if not args.keep:
        shutil.rmtree(WORKING_DIR)



def header(test="Easy", enc=Encoding.MINIMAL):
    match enc:
        case Encoding.EFFICIENT: enc = "Efficient"
        case Encoding.EXTENDED: enc = "Extended"
        case _: enc = "Minimal"
    return test + " Test (" + enc + " Encoding)"


def test_easy(silent=False, enc=Encoding.MINIMAL, out_dir=""):
    # read /puzzles/p096_sudoku.txt
    filename = PUZZLE_DIR+"p096_sudoku.txt"
    file = open(filename, "r")
    # each puzzle is 9 lines long
    # headed by "Grid xx"
    # where xx is the puzzle number
    # the first puzzle is 1
    # the last puzzle is 50

    for i in range(50):
        # read the header
        file.readline()
        # read the puzzle
        puzzle = ""
        for _ in range(9):
            puzzle += file.readline()
        # convert to CNF
        cnf = SudokuToCNF().convert(puzzle, enc)
        # write to file
        mkdir = "mkdir -p " + WORKING_DIR+"easy/cnf"
        os.system(mkdir)

        # pad number in filename with zero for single digits
        filename = WORKING_DIR+"easy/cnf/p096_sudoku_" + \
            str(i+1).zfill(2) + ".cnf"

        outfile = open(filename, "w")
        outfile.write(cnf)
        outfile.close()

    # call sat_solve
    sat_solve(silent, WORKING_DIR+"easy/", 50, out_dir, header("Easy", enc))


def test_hard(silent=False, enc=Encoding.MINIMAL, out_dir=""):
    # read /puzzles/p096_sudoku.txt
    filename = PUZZLE_DIR+"top95"
    file = open(filename, "r")
    # each puzzle is one line, there are 95 puzzles

    for i in range(95):
        # read the puzzle
        puzzle = file.readline()
        # convert to CNF
        cnf = SudokuToCNF().convert(puzzle, enc)
        # write to file
        mkdir = "mkdir -p " + WORKING_DIR+"hard/cnf"
        os.system(mkdir)

        # pad number in filename with zero for single digits
        filename = WORKING_DIR+"hard/cnf/p096_sudoku_" + \
            str(i+1).zfill(2) + ".cnf"

        outfile = open(filename, "w")
        outfile.write(cnf)
        outfile.close()

    sat_solve(silent, WORKING_DIR+"hard/", 95, out_dir, header("Hard", enc))


def sat_solve(silent, dir="", c=50, out_dir="", header=""):
    # iterate through CNF output and call minisat on each
    if not silent:
        print(header)
    os.system("mkdir -p " + dir)
    times = []
    to_out = ""
    for i in range(c):
        filename = dir+"cnf/p096_sudoku_" + str(i+1).zfill(2) + ".cnf"
        outfile = dir + "sol/p096_sudoku_" + str(i+1).zfill(2) + ".out"
        mkdir = "mkdir -p " + dir + "sol" + " " + dir + "stat"
        os.system(mkdir)
        # minisat command called as minisat <filename> <filename>.out | grep "CPU time" > <filename>.stat
        command = "minisat " + filename + " " + \
            outfile
        # intercept stdout, don't let it print to terminal
        output = subprocess.Popen(
            command, shell=True, stdout=subprocess.PIPE).communicate()[0]
        output = output.decode("utf-8").split("\n")
        # get the CPU time from the output
        for line in output:
            if "Memory used" in line:
                to_out += "---Test " + str(i+1).zfill(2) + "-"*24 + "\n"
                to_out += line + "\n"
            if "CPU time" in line:
                to_out += line + "\n"
                times.append(re.findall(r"[-+]?\d*\.\d+|\d+", line))

    if times != []:
        to_out += "---Average CPU time"+"-"*24 + "\n"
        to_out += str(round(sum([float(x[0])
                      for x in times])/len(times), 4)) + " seconds"

    if to_out != "":
        if not silent:
            print(to_out)
        else:
            # check if a file was specified
            to_out = header + "\n" + to_out
            if out_dir[-4:] == ".txt":
                # write to file
                outfile = open(out_dir, "w")
                outfile.write(to_out)
                outfile.close()
            else:
                # write to file
                outfile = open(out_dir + "test_results.txt", "w")
                outfile.write(to_out)
                outfile.close()


if __name__ == "__main__":
    main()

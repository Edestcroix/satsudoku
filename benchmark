#! /usr/bin/env python3
import argparse
import os
import shutil

import src.constants as c
import src.convertSUD as Sud
from src.benchmarking import SatSolver, TestData, Tester
from src.convertCNF import Encoding
from src.tableMD import create as create_table

CACHE_DIR = c.CACHE_DIR
PUZZLE_DIR = c.PUZZLE_DIR
RESULTS_DIR = c.RESULTS_DIR

PUZZLES = c.PUZZLES
ROUND_AVG = c.ROUND_AVG


def main():
    # set up argument parser
    # with argument flag -c
    # which shows the CPU time for each puzzle
    parser = argparse.ArgumentParser(
        description="Run tests on the sudoku solver")
    args = setup_args(parser)
    if args.clean:
        shutil.rmtree(RESULTS_DIR)
        exit(0)

    all_tests, summary, keep, decode = \
        (True, True, True, True) if args.complete\
        else (args.all, args.summarize, args.keep, args.decode)

    if summary and not all_tests:
        print("Error: -S must be used with -a")
        exit(1)

    make_dirs()
    run_tests(args, all_tests, summary, keep, decode)


def make_dirs():
    if not os.path.isdir(CACHE_DIR):
        os.mkdir(CACHE_DIR)

    if not os.path.isdir(RESULTS_DIR):
        os.mkdir(RESULTS_DIR)


def setup_args(parser):
    parser.add_argument("-s", "--silent", action="store_true",)
    # add argument flag -t to specify which test to run
    # default is to run all tests
    parser.add_argument("-t", "--test", type=str, default="",
                        help="test to run (standard, hard)")
    parser.add_argument("-e", "--enc", type=str, default="",
                        help="encoding to use (minimum, efficient, extended)")
    parser.add_argument("-a", "--all", action="store_true",
                        help="run all tests")
    parser.add_argument("-k", "--keep", action="store_true",
                        help="keep converted CNF files and solver output")
    parser.add_argument("-S", "--summarize", action="store_true",
                        help="summarize results from -a")
    parser.add_argument("-d", "--decode", action="store_true",
                        help="decode solved puzzles")
    parser.add_argument("-C", "--complete", action="store_true",
                        help="run all tests and summarize results")
    parser.add_argument("-c", "--clean", action="store_true",
                        help="clean benchmark directory")
    return parser.parse_args()


def run_tests(args, all_tests, summary, keep, decode):
    if all_tests:
        # fail if -t or -e specified with -a
        if args.test != "" or args.enc != "":
            print("Error: -a/-C cannot be used with flags other -s")
            return
        test_all(summary, args.silent)
    else:
        run_single_test(args)

    if decode:
        copy_solution_dir(args)
    if keep:
        copy_working_dir(args)
    else:
        shutil.rmtree(CACHE_DIR)


def run_single_test(args):
    if args.enc in ["minimal", "efficient", "extended"]:
        enc = Encoding(args.enc.upper())
    elif args.enc == "":
        enc = Encoding.MINIMAL
    else:
        print("Error: invalid encoding")
        exit(1)

    out = f"{RESULTS_DIR}test_results.md"
    test = args.test.capitalize() if args.test != "" else "Standard"
    testdata = TestData(args.silent, test, enc, *PUZZLES[test])
    solver = SatSolver(PUZZLES[test][1])
    tester = Tester(testdata, solver)
    tester.test(out)


def print_if_not(b, str):
    None if b else print(str)


def copy_solution_dir(args):
    out_dir = RESULTS_DIR
    # add trailing slash if not present
    if out_dir[-1] != "/":
        out_dir += "/"
    decode_solutions()
    if os.path.isdir(f"{out_dir}solutions"):
        shutil.rmtree(f"{out_dir}solutions")
    shutil.move(f"{CACHE_DIR}/solutions", out_dir)

    print_if_not(
        args.silent, f"Decoded solutions written to {out_dir}solutions")


def copy_working_dir(args):
    # move contents cache dir to results dir
    out_dir = RESULTS_DIR
    # add trailing slash if not present
    if out_dir[-1] != "/":
        out_dir += "/"

    if not os.path.isdir(out_dir):
        os.mkdir(out_dir)
    if os.path.isdir(f"{out_dir}.working"):
        shutil.rmtree(f"{out_dir}.working")
    shutil.move(CACHE_DIR, out_dir)
    if os.path.isdir(f"{out_dir}encodings"):
        shutil.rmtree(f"{out_dir}encodings")
    os.rename(f"{out_dir}.working", f"{out_dir}encodings")

    print_if_not(args.silent, "Converted CNF files and solver output saved to " +
                 out_dir+"encodings")


def summarize(results):
    sum_file = f"{RESULTS_DIR}summary.md"
    def header_func(x): return "Averages ― Standard Puzzles" if\
        x == 1 else "Averages ― Hard Puzzles"
    cols = ["Encoding", "Decisions", "Decision Rate (dcsns/sec)",
            "Propositions", "Proposition Rate (props/sec)", "CPU Time (seconds)"]
    with open(sum_file, "w") as f:
        f.write(create_table("Results Summary", results,
                cols, sep_func=header_func, new_line=False))


def test_all(summary=False, silent=False):
    out = RESULTS_DIR
    msg = "Testing {0} puzzles with {1} encoding..."
    print_if_not(silent, f"Running all tests, outputting to {out}")
    print_if_not(silent, "This may take a while...")

    testdata = TestData(True, "Standard", Encoding.MINIMAL,
                        *PUZZLES["Standard"])

    # initialize tester with standard puzzles
    tester = Tester(testdata, SatSolver(PUZZLES["Standard"][1]))

    results, i = [], 1

    # iterates through all test puzzle files and all encodings
    for test in PUZZLES.keys():
        # update tester parameters when switching tests
        tester.update_params(
            TestData(True, test, Encoding.MINIMAL, *PUZZLES[test]))
        for enc in Encoding:
            name, t = enc.name.lower(), test.lower()
            out_file = f"{out}{str(i).zfill(2)}-{t}-{name}.md"

            print_if_not(silent, format(msg.format(t, name)))
            tester.update_encoding(enc)
            results.append(tester.test(out_file))
            i += 1

    print_if_not(silent, "Done!")
    if summary:
        summarize(results)
        print_if_not(silent, f"Summary saved to {out}summary.md")


def decode_solutions():
    # decode solutions from minisat output
    standard_dir = f"{CACHE_DIR}/sat/standard/"
    hard_dir = f"{CACHE_DIR}/sat/hard/"
    if os.path.exists(standard_dir):
        decode_dir('solutions/standard/', standard_dir,
                   'solutions/standard/sudoku_')
    if os.path.exists(f"{CACHE_DIR}/sat/hard"):
        decode_dir('/solutions/hard/', hard_dir, 'solutions/hard/sudoku_')


def decode_dir(out_dir, in_dir, out_name_head):
    os.system(f"mkdir -p {CACHE_DIR}/{out_dir}")
    # count how many files are in standard_dir
    count = len(list(os.listdir(in_dir)))
    for i in range(count):
        filename = f"{in_dir}sudoku_{str(i + 1).zfill(2)}.out"
        # read file and pass to Sud.convert
        with open(filename, "r") as in_file:
            lines = in_file.readlines()

            table = sudoku_to_table(Sud.convert(lines[1]), i)
            outfile = f"{CACHE_DIR}/{out_name_head}{str(i + 1).zfill(2)}.md"

            with open(outfile, "w") as out:
                out.write(table)


def sudoku_to_table(sudoku, i):
    # convert a sudoku puzzle to a table
    sudoku = sudoku.replace(" ", "").split("\n")
    sudoku = [line for line in sudoku if line != ""]
    sudoku = [list(line) for line in sudoku]
    dummy = [""] * 9
    sudoku = [dummy] + sudoku

    return create_table(f"Solution {str(i+1).zfill(2)}", sudoku, new_line=False, sep=False)


if __name__ == "__main__":
    main()

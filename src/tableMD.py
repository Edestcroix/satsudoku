def create(title, rows, col_titles, sep_every=3, sep_func=None, new_line=True):
    # find the longest string in each column
    col_widths = [max(len(str(x)) for x in col)
                  for col in zip(*rows + [col_titles])]
    out = f"# {title}\n"
    sep_count = 0
    sep_line = "|-" + "-|-".join("-" * n for n in col_widths) + "-|" + "\n"

    for i, row in enumerate(rows):
        if i % sep_every == 0:
            sep_count += 1
            out += __table_sep(sep_count, sep_func,
                                    sep_line, col_widths, col_titles)

        out += "| " + " | ".join((str(x).ljust(col_widths[j])
                                  for j, x in enumerate(row))) + " |\n"

    if new_line:
        out += "\n"
    return out

def __table_sep(sep_count, sep_func, sep_line, col_widths, col_titles):
    out = ""
    # when a separator of some kind is defined
    # (either a header or a function)
    # print the separator at the interval specified by sep_every
    if sep_func != None:
        # the header is generated by the function
        # passed as an argument to sep_func
        # (this is so that the header can be dynamic)
        head = sep_func(sep_count)

        sep_header = (
            f"## {head.ljust(sum(col_widths) + 3 * (len(col_widths) - 1))}"
            + "\n\n"
        )
        out += "\n"+sep_header if sep_count > 1 else sep_header
    # if there are no column titles, and no separator function
    # a separator line needs to be printed
    if sep_func is None:
        out += sep_line

    out += "| " + " | ".join((str(x).ljust(col_widths[j])
                              for j, x in enumerate(col_titles))) + " |\n"
    out += sep_line
    return out
